# Akka

Akka 是一个构建并发和分布式 JVM 应用程序的工具包和运行时。

```xml
<dependency>
  <groupId>com.typesafe.akka</groupId>
  <artifactId>akka-actor_2.12</artifactId>
  <version>2.5.22</version>
</dependency>
```

## Actor模型

​	用于并发计算的 actor 模型基于各种称为 *actor* 的原语来构建系统。Actor 执行操作来响应称为*消息* 的输入。这些操作包括更改 actor 自己的内部状态，以及发出其他消息和创建其他 actor。所有消息都是异步交付的，因此将消息发送方与接收方分开。正是由于这种分离，导致 actor 系统具有内在的并发性：可以不受限制地并行执行任何拥有输入消息的 actor。

​	在 Akka 术语中，actor 看起来就像是某种通过消息进行交互的行为神经束。像真实世界的演员一样，Akka actor 也需要一定程度的隐私。您不能直接将消息发送给 Akka actor。相反，需要将消息发送给等同于邮政信箱的 actor *引用*。然后通过该引用将传入的消息路由到 actor 的邮箱，以后再传送给 actor。Akka actor 甚至要求所有传入的消息都是无菌的（或者在 JVM 术语中叫做*不可变的*），以免受到其他 actor 的污染。

​	与一些真实世界中演员的需求不同，Akka 中由于某种原因而存在一些看似强制要求的限制。使用 actor 的引用可阻止交换消息以外的任何交互，这些交互可能破坏 actor 模型核心上的解耦本质。Actor 在执行上是单线程的（不超过 1 个线程执行一个特定的 actor 实例），所以邮箱充当着一个缓冲器，在处理消息前会一直保存这些消息。消息的不可变性（由于 JVM 的限制，目前未由 Akka 强制执行，但这是一项既定的要求）意味着根本无需担心可能影响 actor 之间各种共享的数据的同步问题；如果只有共享的数据是不可变的，那么根本不需要同步。

​	该[角色模型](http://en.wikipedia.org/wiki/Actor_model)提供了一个抽象的编写并发和分布式系统更高的水平。它减轻了开发人员处理显式锁定和线程管理的麻烦，使得编写正确的并发和并行系统变得更加容易。演员是由Carl Hewitt在1973年的论文中定义的，但是已经被Erlang语言推广，并且例如在爱立信用于建立高度并发和可靠的电信系统。